# Weekly I Learned 7

## Implementing B-Trees

### Rebalancing

일부 B-Tree 구현에서는 분할/병합 비용을 줄이기 위해 같은 레벨에서 노드를 리밸런싱하기도 한다. 즉, 노드의 추가 없이, 동일 레벨의 다른 노드로 원소를 이동시킨다.

이렇게 하면 분할/병합 비용이 줄어드는 대신 리밸런싱 비용이 높아질 수도 있지만, 노드의 점유율을 높이고 트리의 높이를 낮추어 B-Tree 탐색의 성능을 높일 수 있다.

리밸런싱을 적극 활용하는 대표적인 B-Tree 구현체로 B*-Tree(B-Star-Tree)가 있다. B*-Tree는 분할 전에 먼저 형제 노드(오른쪽 노드)의 점유 상태도 확인하고, 형제 노드에 여유 공간이 있다면 리밸런싱을 시도한다. 형제 노드도 꽉 찼다면, 두 노드를 $2/3$ 씩 채워진 세 노드로 분할한다.

앞서 말했듯이 이 방식은 리밸런싱 비용이 들지만, 메모리 낭비를 줄이고 B-Tree 탐색 성능을 향상시킬 수 있는 데에 이점이 있다.

### Right-Only Appends

B-Tree는 모든 노드가 정렬된 상태로 유지되며, 데이터를 리프 노드에 저장한다. 이 때 새로운 값이 Auto-Increment 방식의 수라면, 항상 기존 값보다 크다. 따라서 탐색 없이 가장 오른쪽 리프 노드에 추가하면 된다.

PostgreSQL은 이러한 탐색 과정을 건너뛰고 캐시된 페이지의 알맞은 위치에 키를 바로 삽입하며, SQLite는 오른쪽에 새로운 노드를 할당하고 부모 노드에 포인터를 추가한다.

- **벌크 로딩**

    벌크 로딩이란, 수천에서 수백만 개의 정렬된 데이터를 한꺼번에 트리에 삽입하는 방식이다. 효율성을 위해 일반적인 삽입 방식보다 최적화된 구조를 사용한다.

    이렇게 데이터가 이미 정렬되어 있다면, B-Tree의 오른쪽 끝 노드에만 계속 추가하면 된다. 따라서 일반적인 삽입처럼 탐색하거나 중간 노드를 수정할 필요가 없으며, 빠르고 단순하게 트리를 구성할 수 있다.

    정렬된 데이터를 리프 페이지 단위로 나눠서 리프 레벨부터 노드를 생성하고, 상위 노드를 만들 때는 이미 모든 자식 노드가 준비되어 있으므로 자식 노드의 첫번째 키를 부모 노드에 복사해주면 노드 분할/병합 없이 오른쪽 노드만 계속 추가하는 방식으로 벌크 로딩을 구현할 수 있다.

### Compression

데이터를 압축하지 않고 그대로 저장하면 공간 낭비가 크다. 따라서 대부분의 DB는 압축 라이브러리를 연동하는 기능을 제공한다.

압축률과 접근 속도 간에는 성능 면에서 Trade-off가 존재한다. 압축률이 높으면 저장 공간을 효율적으로 쓸 수 있고, 한번에 더 많은 데이터를 읽을 수 있어 I/O 효율이 높아진다. 그러나 압축 해제를 하려면 CPU 계산량이 많아지고, RAM도 더 필요하다.

대부분의 DB는 기본적으로 페이지 단위로 압축을 한다. 파일 전체 압축 방식은, 일부만 수정해도 전체 파일을 다시 압축해야 한다는 점에서 너무 비효율적이기 때문에, 독립적으로 작동 가능한 페이지 단위 압축을 채택하였다.

압축 알고리즘을 비교할 때는 다양한 지표를 참고하여 목적에 맞는 알고리즘을 골라야 한다. 로그 데이터와 같이 읽기보다 쓰기가 많다면 빠른 압축 알고리즘이 좋을 것이며, 분석과 같이 읽기가 많다면 압축률이 높은 알고리즘이 좋을 것이다. Squash Compression Benchmark와 같은 벤치마크 자료를 참고하면 이러한 목적별로 압축 알고리즘의 효용성을 비교할 수 있다.

### Vacuum and Maintenance

Slotted Page 방식의 설계 상, 노드의 삽입/삭제/갱신 및 분할/병합 등이 계속 일어나면 단편화가 발생하여 연속된 물리적 공간이 부족한 페이지가 생길 수 있다.

이때 셀 포인터가 가리키는 셀, 즉 사용중인 셀의 데이터는 Live 상태라고 하며, 셀 포인터가 가리키지 않아 참조할 수 없는 셀은 Garbage 라고 한다. 이 가비지 데이터는 내부적으로 데이터가 존재할 수 있으나, 쓰임이 없어져 참조가 끊어졌기 때문에 null과 같은 취급을 받는다. 즉 새로운 데이터로 덮어씌워질 수 있기 때문에 이를 0과 같은 값으로 채우는 작업은 의미없이 DB의 성능을 저하시키는 작업일 것이다.

- **업데이트와 삭제로 인한 단편화**

    단편화를 다시 설명해보자. 여러 셀을 삭제하다 보면 페이지에 띄엄띄엄 가비지가 생긴다. 그러나 이 공간이 연속된 블록이 아니기 때문에 데이터 삽입 시 재사용하기 어렵다. 결국 남는 공간을 합치면 충분한 공간이 있으나, 연속된 공간이 아니기에 삽입이 불가능한 현상이 생기는데, 이를 단편화(*Fragmentation*)라고 한다.

    데이터를 삽입 순서로 저장하면 실제 디스크 순서와 논리 순서가 맞지 않을 수 있다. 반면에 키 정렬 순서대로 저장하면 디스크 접근이 더 예측 가능하고 연속적이므로 캐시 프리페치에 유리하다.

    데이터 업데이트가 일어날 때 어떻게 단편화가 일어날까? B-Tree에서는 기존 셀을 수정하지 않고 새 버전을 새 셀로 추가한다. 이전 셀과의 참조를 끊고, 이 새 버전의 셀을 셀 포인터가 참조할 수 있도록 한다. 이렇게 이전 셀을 더 이상 참조되지 않는 가비지 상태가 되며, 단편화가 발생한다.

- **페이지 단편화**

    컴팩션(*Compaction*)이란, 상술한 단편화를 제거하는 작업으로, 가비지가 차지하는 공간을 회수하고, Live 상태인 셀만 모아서 논리적인 정렬 순서대로 페이지를 다시 구성하는 작업이다.

    컴팩션은 백그라운드 스레드에서 실행되며, 페이지가 쓰기 작업 중이 아닐 때 수행된다. 이를 통해 단편화를 해결하고 새로운 데이터를 삽입 가능한 연속 공간을 확보할 수 있다.

    재구성된 페이지는 다른 위치에 새 페이지로 저장될 수 있으며, 페이지 ID가 바뀌므로 부모 노드 및 형제 노드에서 참조하는 포인터도 함께 업데이트해야 한다. 이렇게 새 페이지가 생기면 이전 페이지는 Free Page List에 등록하여 다음에 새 데이터 저장 시 재사용한다.