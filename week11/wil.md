# Weekly I Learned 11

## B-Tree Variants

B-Tree를 효율적으로 구현하기 위해 다음과 같은 다양한 변형 B-Tree가 등장했다.

- Copy-on-write B-Tree
- Lazy B-Tree
- FD-Tree
- Bw-Tree
- Cache-oblivious B-Tree

### Copy-on-Write

쓰기 시 복사(COW, *Copy-on-write*) B-Tree는 불변 노드로 이루어진다는 특징을 가진다. 따라서 기존 노드를 수정하는 연산은, 그 노드의 복제본을 수정하여 저장하는 방법으로 구현한다. 즉, MVCC를 적극적으로 지원하는 구조이다.

락(DB이므로 사실은 래치) 없이, 읽기 작업과 쓰기 작업 각각이 애초에 분리되어 실행되어 데이터 무결성과 일관성을 보장할 수 있기 때문에 동시성 문제 해결을 매우 간단한 방법으로 풀어낼 수 있다.

그러나 노드 복사로 인해 디스크 공간과 CPU 자원이 추가로 사용된다는 단점이 있다.

- **Implementing Copy-on-Write: LMDB**

LMDB(*Lightning Memory-Mapped Database*)는 OpenLDAP에서 사용하는 COW 기반 Key-Value 저장소이다. MVCC를 포함하여 COW B-Tree의 특징을 대부분 가진다.

추가적으로, 루트 버전은 현재 버전과 새롭게 커밋 예정인 버전으로 두개만 유지할 수 있도록 구현하며, 형제 노드 포인터가 없어서 순차 탐색시에는 부모 노드로 올라가 다시 내려오는 특징을 가진다.

### Abstracting Node Updates

디스크의 페이지를 업데이트 하려면 먼저 메모리 상태부터 수정해야 한다. 노드를 메모리에 어떻게 표현할 것인가에 따라 다양한 방식으로 수정이 가능하다.

- Raw Binary 기반

노드 데이터를 포인터와 구조체를 통해 직접 해석한다. 메모리 효율적이나 메모리 안전성과 동시성 관리가 복잡하다.

- 언어 네이티브 구조체로 변경

노드를 언어의 객체로 구체화하여 조작한다. 동시성 관리가 간편하나 메모리 오버헤드가 증가한다.

- 래퍼 객체를 통해 변경

노드 버퍼 접근을 래퍼 객체를 통해 처리한다. Java와 같이 메모리 관리를 자동으로 해주는 언어에서 사용하며, 설계가 복잡하다는 단점이 있다.

### Lazy B-Trees

지연형(*Lazy*) B-Tree는 동일 노드에 대한 반복 업데이트를 버퍼링하여 DB에 대한 I/O 요청을 줄인다. 다음에 설명하는 WiredTiger와 Lazy-Adaptive Tree 구현이 이를 따르며, 공통적으로 쓰기 작업을 배치 처리해서 I/O 요청 최소화를 만족시켰다.

- **WiredTiger**

MongoDB의 스토리지 엔진인 WiredTiger는 디스크와 메모리의 페이지 포맷이 다르다. 디스크에서 페이지를 읽어오면, 메모리에서 해당 노드를 객체로 구체화하여 저장한다. 변경 사항은 업데이트 버퍼에 저장하며, 업데이트 버퍼는 동시성에 유리한 Skiplist로 구현되어 있다.

WiredTiger는 다음의 방식으로 동작한다.

- 읽기 시, 원본 페이지 + 버퍼 내용을 병합하여 최신 데이터를 제공한다.
- 쓰기 시, 버퍼를 flush하며 디스크 페이지와 동기화한 후 덮어쓴다.
- 페이지 크기가 너무 크면 분할, 너무 작으면 병합하며, 백그라운드 스레드가 실행하여 R/W 지연은 최소화한다.

- **Lazy-Adaptive Tree**

지연 적응형(LA, *Lazy-Adaptive*) Tree는 노드 별로 버퍼를 가지는 것이 아니라 서브트리 단위로 버퍼를 가지며, 루트에서 하위 노드로 버퍼 내용이 계단식으로 전파된다.

LA Tree는 다음의 방식으로 동작한다.

- 루트 버퍼에 삽입
- 상위 버퍼가 가득 차면? -> 하위 버퍼로 전파
- 최종적으로 리프 노드에서 한꺼번에 반영
- 리프에서 한 번의 디스크 접근으로 일괄 삽입, 수정, 삭제

### FD-Trees

FD(*Flash Disk*) Tree는 버퍼를 B-Tree 형태로 구현하고, 꽉 찬 버퍼를 불변 형태로 저장하여 구현된다.

FD Tree는 디스크에서 값비싼 연산인 랜덤 쓰기를 줄이기 위하여, 순차 쓰기 방식으로 구현한다. 구체적으로 다음에 설명할 Fractional Cascading과 Logarithmic Runs의 개념이 사용된다.

- **Fractional Cascading**

여러 정렬된 배열에서 같은 값을 반복해서 검색해야 할 때, 각각을 이진 탐색 한다면 $N\ log\ n$ 의 비용이 들 것이므로 비용이 크다. 그러나 처음의 탐색 결과를 다음 단계의 탐색에 재사용하도록 요소간 다리를 만들면 이를 좀 더 줄일 수 있을 것이다.

예를 들어, A1에서 이진 탐색한 결과를 얻고, A2에서는 A1의 결과에서 연결된 다리 요소 근처부터 검색을 시작하면 훨씬 빠른 속도로 원하는 요소에 접근 가능할 것이다.

- **Logarithmic Runs**

업데이트가 발생할 때마다 디스크에 쓰면 비효율적이다. 따라서 데이터를 작은 단위로 저장하고, 크기를 점점 키워가며 병합한다.

Logarithmic Runs의 작동 방식은 다음과 같이 간단하게 요약할 수 있다.

1. head tree(아직은 작은 B-Tree 구조이다.)에 데이터를 저장한다.
2. 일정량이 쌓이면 Level 1 정렬 배열로 내려보낸다.
3. Level 1이 꽉 차면 Level 2 정렬 배열로 내려보낸다.. (반복)
4. 각 Level은 이전보다 $k$ 배 큰 크기로 구성한다. (지수적 확장)

이를 통해 디스크의 정렬 구조를 유지하며 한번에 많은 데이터 쓰기가 가능하다.