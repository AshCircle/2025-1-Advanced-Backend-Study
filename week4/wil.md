# Weekly I Learned 4

## B-Tree Basics

### Ubiquitous B-Trees

- **Counting Keys**

    B-Tree의 각 노드에는 $N$ 개의 구분 키와 $N + 1$ 개의 자식 포인터를 저장할 수 있음이 자명하다.

- **B-Tree Node Splits**

    우리는 메모리에 표현 범위를 초과하는 수의 값을 저장하면서 오류가 난 상황을 *오버플로우*라고 표현한다.

    B-Tree에서는 오버플로우의 의미가 약간 다른데, 저장 공간이 넘치는 것이 **임박한 상황**을 *오버플로우* 상태라고 표현한다.

    B-Tree의 오버플로우 상태는 다음과 같은 조건을 만족한다.

    1. 리프 노드: 노드에 $N$ 개의 키-값 쌍을 저장할 수 있는데, 새로운 키-값 쌍 삽입 시 용량이 초과되는 경우

    2. 루트 노드와 내부 노드: 노드에 $N + 1$ 개의 포인터를 저장할 수 있는데, 새로운 포인터 추가 시 용량이 초과되는 경우

    이러한 오버플로우 상태에서 노드 삽입 시, 노드 분할이 일어난다.

    노드 분할은 다음과 같이 4단계로 이루어진다.

    1. 새로운 노드 할당

    2. 분할 노드 키의 절반을 새로운 노드로 복사

    3. 새로운 키를 알맞은 노드에 삽입

    4. 분할 노드의 부모 노드에 분할 키와 새로운 노드를 가리키는 포인터 추가

    4번 단계에서 부모 노드가 오버플로우 상태일경우, 노드 분할이 이루어지며, 이렇게 재귀적으로 노드 분할이 일어날 수 있다.

    루트 노드도 분할될 수 있으며, 이는 즉 트리 전체에 용량이 부족한 상황이다. 이때는 트리의 높이가 한 레벨 증가할 수밖에 없다.


- **B-Tree Node Merges**

    우리는 메모리에 표현 범위 미만의 수의 값을 저장하면서 오류가 난 상황을 *언더플로우*라고 표현한다.

    B-Tree에서는 언더플로우의 의미가 약간 다른데, 키 개수가 최소 허용치 미만인 상태를 *언더플로우* 상태라고 표현한다.

    B-Tree의 언더플로우 상태는 다음과 같은 조건을 만족한다.

    1. 리프 노드: 노드에 $N$ 개의 키-값 쌍을 저장할 수 있고, 두 노드의 총 키-값 쌍의 수가 $N$ 보다 작거나 같은 경우

    2. 루트 노드와 내부 노드: 노드에 $N + 1$ 개의 포인터를 저장할 수 있고, 두 노드의 포인터 수의 합이 $N + 1$ 보다 작거나 같은 경우

    이러한 언더플로우 상태에서 노드 삭제 시, 노드 병합이 일어난다.

    노드 병합은 다음과 같이 3단계로 이루어진다.

    1. 모든 키를 오른쪽 노드에서 왼쪽 노드로 복사

    2. 부모 노드에서 오른쪽 노드를 가리키는 포인터 제거

    3. 오른쪽 노드 제거

    노드 병합 또한 노드 분할처럼 재귀적으로 전파될 수 있다.

## File Formats

### File Formats

메모리 접근은, 가상 메모리를 사용하면 오프셋을 직접 관리하지 않아도 된다.

디스크 접근은, 명시적인 오프셋 지정과 시스템 호출이 필요하며, 이에 맞는 파일 포맷 설계가 필요하다.

이 장에서는 B-Tree 등 여러 형태의 디스크 기반 자료 구조 설계의 일반 원칙을 설명하며, 가변 자료 구조 구현에서 중요한 주제인 페이지 레이아웃, 분할, 재배치에 대해 설명한다.

### Motivation

C언어는 Java와 같은 가비지 컬렉션이 없기 때문에 malloc, free 등을 통해 개발자가 메모리를 수동으로 할당하고 해제한다.

파일 포맷 설계는 이렇게 C와 같은 메모리 비관리형 프로그래밍 언어로 자료 구조를 설계하는 것과 유사하다. 즉, 단편화와 가비지 컬렉션을 직접 처리해야 하며, 데이터 배치가 성능에 직접적인 영향을 준다.

메모리 상에서는 라이브러리 등으로 쉽게 처리하여 저장할 수 있으나, 디스크 상에서 OS나 파일 시스템의 추상화만으로 구현하기는 부족한 점이 많다.

### Binary Encoding

데이터를 효율적으로 디스크에 저장하려면 컴팩트(공간을 적게 차지)하고 직렬화와 역직렬화(write & read 시 변환)가 쉬운 포맷으로 인코딩해야 한다.

- **기본형**

    엔디언(Endian, *Endianness*)은 바이트 배열 순서를 정의한다.

    - 빅 엔디언

        최상위 바이트(MSB, *Most Significant Byte*)가 가장 앞쪽(가장 작은 주소)에 오는 저장 방법이다.

    - 리틀 엔디언

        최하위 바이트(LSB, *Least Significant Byte*)가 가장 앞쪽(가장 작은 주소)에 오는 저장 방법이다.

    정수형을 바이너리 형식으로 표현할 때, byte(1바이트), short(2바이트), int(4바이트), long(8바이트)로 표현 가능하다.

    실수형(부동 소수점)을 바이너리 형식으로 표현할 때, 단정밀도는 float(4바이트), 배정밀도는 double(8바이트)로 표현 가능하다.

- **문자열과 가변 길이 데이터**

    가변 길이 데이터는 배열의 크기 또는 문자열의 길이를 나타내는 숫자와 그 크기의 실제 데이터로 구성된다.

    위와 같은 형식을 UCSD 문자열 또는 파스칼 문자열이라고 부른다.

- **비트 묶음형 데이터**

    - 불리언

        불리언 자료형은 1바이트로 표현할 수 있으며, 낭비를 줄이기 위해 1비트씩 사용하도록 묶어서 packed boolean 형태로 저장되기도 한다.

    - 열거형

        정수형으로 표현될 수 있으며, 자주 반복되는 값이지만 종류가 많지 않은 경우에 적합하다.

    - 플래그

        서로 배타적이지 않은(동시에 참일 수 있는) 여러 boolean 상태를 저장할 때는 플래그를 사용한다.

        packed boolean 형태로 저장할 수 있으며, 때문에 각 비트가 하나의 상태를 나타낸다.

        비트 연산을 통해 어떤 flag가 조건을 만족하는지 알아낼 수 있다.