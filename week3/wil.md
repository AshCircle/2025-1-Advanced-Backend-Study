# Weekly I Learned 3

## B-Tree Basics

### B-Tree Basics

저장 자료 구조를 판단하는 속성 중 가변성이 있었음을 기억할 것이다. 불변 저장 자료 구조의 대표적인 예로 LSM이 있으며, (인플레이스 업데이트 방식을 사용하는) 가변 저장 자료 구조의 대표적인 예로 B-Tree가 있음을 배웠다.

가변 저장 자료 구조인 B-Tree는 스토리지 엔진에서 가장 많이 사용되는 자료 구조 중 하나이다. 최신 알고리즘이 아닌데도 아직까지 많은 오픈소스 데이터베이스에서 사용되고 있으며, 이렇게 긴 시간 동안 쓰였기에 검증된 자료 구조라고 할 수 있다.

탐색 트리에는 BST, 2-3 Tree, AVL Tree 등의 일반적인 탐색 트리도 존재하는데, 왜 스토리지 엔진에서 B-Tree 라는 특별한 자료구조를 채택하였는지를 알아보자.

### Binary Search Trees

- **Binary Search Tree란?**

    자료구조, 알고리즘 분석 시간에서 이진 탐색 트리에 대해 배웠을 것이다. BST의 노드는 left-subtree, right-subtree를 두 자식으로 가질 수 있으며, 각 노드의 키는 left-subtree를 구성하는 모든 키 값보다 크고 right-subtree를 구성하는 모든 키 값보다 작다.

- **트리 밸런싱**

    노드의 개수가 $N$개일 때, 이상적인 트리, 즉 균형 트리라면 탐색 시간 복잡도는 $O(\log_2 N)$ 이지만, 트리가 한쪽으로 치우친 불균형 트리라면 최악의 탐색 시간 복잡도는 $O(N)$ 이 된다.

    따라서 탐색 성능을 극대화 하려면 BST의 균형을 맞추어야 하며, 이를 위해서 노드 삽입 및 삭제 시 트리의 일부를 회전하는 작업을 하도록 알고리즘을 개선할 수 있다. 이것이 바로 자료구조 시간에 배운 AVL Tree이다.

- **디스크 기반 스토리지용 트리**

    AVL Tree를 디스크 기반 자료 구조로 사용하기에는 적합하지 않은데, 다음과 같은 이유들 때문이다.

    1. 지역성이 떨어짐

        노드가 순서에 따라 삽입되지 않으므로 새로운 노드와 부모 노드가 가까운 위치에 저장되지 않을 수 있다. 따라서 자식 포인터가 여러 다른 다스크 페이지를 가리킬 수 있다.

        디스크 저장에 적합한 트리는 지역성을 높이기 위해서 높은 팬아웃(자식 수)이 필요하다.

    2. 디스크 탐색 횟수가 많음

        AVL Tree은 $\log_2 N$ 의 높이를 가지는데, 이는 특정 노드를 찾기 위해 $\log_2 N$ 만큼 탐색과 디스크 전송이 필요함을 뜻한다. 이는 후술한 HDD의 임의 접근 횟수를 늘리기 때문에 비효율적이다.

        디스크 저장에 적합한 트리는 디스크 탐색 횟수를 줄이기 위해서 더 낮은 트리 높이를 가져야 한다.

### Disk-Based Structures

- **저장 매체에 따른 차이**

    탐색 비용 관점에서 저장 매체를 비교해 보자.

    - 하드 디스크 드라이브(HDD)

        HDD는 물리적 헤드 이동이 가장 비용이 높은 작업이다. 그러나 이후의 연속된 바이트 I/O는 비용이 낮다. 즉, 임의 접근 성능이 낮으며 순차 접근 성능은 이에 비해서 높다.

        따라서 HDD는 연속된 메모리 섹터의 I/O를 극대화해야 한다.

    - 솔리드 스테이트 드라이브(SSD)

        SSD는 HDD와 같이 물리적인 이동이 없으며, 전기적인 방식으로 탐색한다. 따라서 임의 접근 성능 및 순차 접근 성능이 모두 뛰어나다.

        SSD의 단점은 데이터를 반드시 블록 단위로 지워야 한다는 점인데, 이 때문에 기존에 쓴 데이터가 작은 페이지 단위더라도 해당 페이지가 속한 블록 전체를 지우고 다시 써야 한다.

        따라서 SSD는 여러 개의 작은 쓰기 작업을 하나의 큰 쓰기 작업으로 모아서 처리하는 것이 I/O 작업의 수를 줄일 수 있다.

    앞으로 설명할 B-Tree는 팬아웃을 크게 하고 높이와 노드 포인터 개수, 밸런싱 빈도를 줄인, 디스크 기반 자료 구조로 적합한 트리이다.

### Ubiquitous B-Trees

B-Tree는 키의 순서가 보장되는 자료 구조이다. 이진 탐색을 사용해 특정 키 또는 특정 범위의 쿼리를 찾을 수 있기 때문에 자연스레 특정 키를 찾는데 걸리는 시간은 로그 시간이 된다.

만약 디스크 자료 구조가 BST, AVL-Tree라면 특정 키를 찾는 데 $\log_2 N$ 번 디스크 임의 접근이 필요하지만, B-Tree는 노드 하나에 수십, 수백개의 키를 저장하므로 디스크 임의 접근 수를 유의미하게 줄일 수 있다.

- **B-Tree Hierarchy**

    B-Tree의 노드는 다음과 같이 3가지로 분류된다.

    - 루트 노드 : 트리의 최상위 노드

    - 내부 노드 : 루트와 리프 노드 사이의 모든 노드

    - 리프 노드 : 자식 노드가 없는 최하위 노드

    B-Tree에서 보유 가능한 노드 용량(capacity)과 실제로 담고 있는 키 개수의 비율을 점유율(occupancy)이라고 한다.

    B-Tree에서 팬아웃(각 노드의 최대 키 수)이 높을수록 다음과 같은 이점이 있다.
    
    1. 트리의 높이가 낮아지기에, 디스크 임의 접근 횟수를 줄일 수 있다.

    2. 키와 포인터를 연속된 블록에 저장해, 디스크 임의 접근 횟수를 줄일 수 있다.

    3. 여유 공간이 많기에, 균형 유지 작업이 자주 일어나지 않는다.

    만약 균형 유지 작업이 일어난다면, 노드가 꽉 차서 일어나면 노드를 쪼개며, 노드가 비어서 일어나면 이웃 노드와 합친다.

- **Separator Keys**

    B-Tree 노드에 저장된 키들을 인덱스 엔트리(index entry), 구분 키(separator key), 또는 디바이더 셀(divider cell)이라고 부른다.

    노드의 구분 키 개수를 $N$ 개라고 하자. 그렇다면 자식 노드 포인터 개수는 $N + 1$ 개이다.

    - 양 끝 자식 노드 포인터 $2$ 개
    
        각각 양 끝 구분 키보다 작은 서브트리, 큰 서브트리를 가리킨다.

    - 나머지 자식 노드 포인터 $N - 1$ 개

        두 구분 키 사이 범위로 구성된 서브트리를 가리킨다.

    효율적인 범위 스캔을 위해 리프 노트에 형제 노드를 가리키는 포인터를 저장하기도 한다. 이렇게 하면 다음 값을 찾을 때 부모를 거쳐서 다시 형제로 내려가는 비효율적인 접근을 줄일 수 있다.

- **B-Tree Lookup Complexity**

    전체 키 개수를 $N$ , 각 노드별 키 개수를 $M$이라 했을 때의 시간 복잡도를 알아보자.

    - 전송 횟수 관점

        트리의 높이가 $log_m N$ 이므로, 특정 키를 찾기 위해 $log_m N$ 개의 노드(페이지)에 접근해야 한다.

        따라서 시간 복잡도는 $O(log_M N)$ 이다.

    - 비교 횟수 관점

        각 노드에서 이진 탐색을 이용해 키를 찾으므로 시간 복잡도는 $O(log_2 M)$ 이다.

    따라서 전체 시간 복잡도는 $O(log_2 M) × O(log_M N) = O(log_2 N)$ 와 같다고 할 수 있다.

- **B-Tree Lookup Algorithm**

    B-Tree의 탐색 알고리즘은 두가지로 나눌 수 있다.

    - 포인트 쿼리, 업데이트, 삭제

        정확히 일치하는 키를 찾아야 한다. 특정 키를 찾거나 찾는 데에 실패했을 때 완료된다.

    - 범위 스캔, 노드 삽입

        대상 키 바로 앞의 값을 찾아야 한다.

        범위 스캔은 범위 끝에 도달할 때까지 형제 노드 포인터를 따라간다.