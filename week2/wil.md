# Weekly I Learned 2

## Introduction and Overview

### Column- Versus Row-Oriented DBMS

- **Row-oriented DBMS**

    테이블을 수평으로 분할하며, 같은 로우에 속하는 여러 필드(Field) 값을 함께 저장한다.
    
    이는 전통적인 트랜잭션 처리 시스템(OLTP, *Online Transaction Processing*)에 적합하며, 개별 사용자의 전체 정보(레코드 단위)를 빠르게 읽는 데 유리하다.

    특정 사용자의 모든 필드를 읽을 때는 효율적이나, 모든 사용자의 특정 필드를 읽을 때는 요청하지 않은 필드까지 페이징하기 때문에 비효율적이다.

- **Column-oriented DBMS**

    테이블을 수직으로 분할하며, 같은 칼럼에 속한 값을 연속적으로 저장한다.

    이는 대규모 데이터에 대한 집계 분석 및 통계 처리(OLAP, *Online Analytical Processing*)에 적합하다.

    칼럼 기반 DBMS의 목적에 맞게, 같은 칼럼의 여러 값을 한번에 읽는다면 캐시 효율성에서 이점을 가지며, 자료형별로 값을 저장하면 최적화된 압축 알고리즘을 사용할 수 있기 때문에 저장공간 면에서 이점을 가진다.

### Data Files and Index Files

- **일반 파일 시스템 대비 DBMS의 이점**

    - 저장 효율성
        
        레코드의 저장 오버헤드를 최소화하여 디스크 공간을 효율적으로 사용할 수 있다. DBMS는 데이터 타입, 레이아웃을 최적화하여 패딩 없이 저장하거나 압축을 적용할 수 있다.

    - 접근 효율성
        
        인덱스를 이용하여 빠른 탐색이 가능하며, 불필요한 파일 전체 탐색을 줄일 수 있다. 이는 선형 탐색 대신 로그 시간 복잡도로 원하는 데이터를 찾을 수 있게 해준다.

    - 갱신 효율성
        
        데이터 수정 시에는 블록 단위로 디스크와 데이터를 주고받기 때문에 디스크 입출력을 최소화할 수 있다. DBMS는 버퍼 풀을 통해 메모리 내에서 다수의 수정 작업을 모아 한 번에 디스크에 기록함으로써 I/O 횟수를 줄인다.

- **데이터 파일**

    데이터 파일에는 데이터 레코드를 저장한다.

    - Index-organized table (IOT) 기반

        인덱스에 실제 데이터 레코드를 저장한다.

    - Heap-organized table 기반

        데이터를 삽입 순서대로 저장한다. 데이터 검색 시 데이터의 실제 위치를 가리키는 인덱스가 필요하다.

    - Hash-organized table 기반

        레코드를 각 키의 해시 값에 해당하는 버킷에 저장한다. 버킷 내 레코드를 삽입 순서대로 저장하거나 키 순서대로 저장하면 조회 속도를 향상시킬 수 있다.

- **인덱스 파일**

    데이터 레코드를 효율적으로 검색할 수 있는 별도의 자료구조이다.

    - 클러스터형 인덱스
    
        IOT와 같이 인덱스 정렬 순서대로 데이터를 저장할 때, 이를 클러스터형 인덱스라고 부른다.
        
    - 비클러스터형 인덱스

        보조 인덱스처럼, 실제 데이터가 인덱스 키를 기준으로 정렬되지 않으면 이는 비클러스터형 인덱스라고 부른다.

    데이터 참조 방식별로도 장단점이 존재한다.

    - 직접 참조

        인덱스가 데이터 위치를 직접 가리킨다. 디스크 탐색 횟수는 줄어들지만 레코드를 갱신할 때마다 포인터를 수정해야 하는 단점이 있다.

    - 간접 참조

        인덱스를 통해 기본 키를 찾아 다시 데이터를 찾는다. 이는 보다 유연한 방식이지만 두번 참조해야 하는 단점이 있다. 대신 데이터 위치가 변경되어도 인덱스를 수정할 필요가 없기 때문에, 유지보수에는 유리하다.

### Buffering, Immutability, and Ordering

DB의 자료구조는 다음과 같은 3가지 속성으로 판단할 수 있다.

- **버퍼링**

    데이터를 디스크에 쓰기 이전에 일부를 메모리에 저장하는 것을 말한다. 디스크와 데이터를 주고 받는 가장 작은 전송 단위가 블록이기 때문에, 이를 채워서 쓰면 디스크 I/O를 줄여서 성능을 높일 수 있다.

- **불변성** 또는 가변성

    파일을 갱신할 때 똑같은 자리에 다시 쓰는가 여부를 말한다. 불변 구조에서는 한번 쓴 파일 내용은 고칠 수 없으며, Copy-on-Write와 같은 방식을 통해 파일 끝에 내용을 추가하는 방식을 채택한다.
    
    왜 불편하게 불변성을 채택했을까? 이유는 이것이 동시성 제어와 장애 복구에 유리하기 때문이다. 여러 쓰기 작업이 동시에 발생할 때, 기존 데이터를 덮어쓰지 않으면 충돌 가능성이 줄어든다. 또한 복구 시 이전 버전을 그대로 보존함으로써 트랜잭션 로그를 기반으로 손쉽게 복원할 수 있다.

- **순서화**

    디스크에 데이터 레코드를 키 순서대로 저장하는가 여부를 말한다. 인접한 키는 디스크의 연속한 세그먼트에 저장된다. 순서화는 검색뿐만 아니라 범위 스캔에 매우 중요한 요소이다.
    
    만일 순서화를 적용하지 않는 DB라면 쓰기 시간을 최적화할 수 있겠지만, 검색이 느려질 것이다.
