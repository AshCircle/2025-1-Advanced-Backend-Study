# Weekly I Learned 1

## Storage Engines

### DB & DBMS

- **DB vs DBMS**

    DB는 *DataBase*의 약자로, 데이터를 모아둔 구조를 뜻한다.

    DBMS는 *DataBase Management System*의 약자로, DB와 같은 데이터들을 다룰 수 있는 전체 소프트웨어 구조이다.

    데이터베이스라는 말을 DBMS를 지칭하는 표현으로 쓰기도 하며, 앞으로의 정리에서도 혼용되어 쓰일 예정이다.

- **DBMS 아키텍쳐 개요**

    - Transport layer: 요청 수신

    - Query processor: 쿼리 최적화

    - Execution engine: 실제 작업 수행

    - **Storage engine**: 디스크에 데이터 저장 및 검색

### 스토리지 엔진의 역할

- **저수준 조작**

    > “데이터베이스가 복잡한 쿼리에 응답할 수 있는 반면, 스토리지 엔진은 데이터를 더욱 세부적으로 살펴보고 간단한 데이터 조작 API를 제공합니다.”

    스토리지 엔진 자체는 CRUD와 같은 낮은 수준의 작업만 수행한다.

    반면 DBMS는 이 스토리지 엔진 위에 더 복잡한 기능 (ex. Join, Group by, Index, Transaction) 등을 구현한다. DBMS가 스토리지 엔진에서 수행 가능한 작업을 토대로 사용자에게 편의를 주는 기능을 추상화하여 제공하는 것이다.

    즉, 스토리지 엔진은, DBMS가 추상화를 통해 편의 기능을 쉽게 다룰 수 있도록 하는 데에 쓰이는 저수준 API와 같다.


- **직렬화된 데이터**

    > "유연성을 위해, 키-값은 정해진 형식 없는 임의의 **바이트 시퀀스**가 될 수 있습니다."

    스토리지 엔진은 키-값을 단순히 임의의 길이의 0과 1의 나열(바이트 시퀀스)로 취급한다. 사용자가 타입을 지정하더라도, 스토리지 엔진은 이를 바이트 시퀀스로만 다룰 뿐이다. 우리는 이러한 바이트 시퀀스를 *직렬화*된 상태라고 부른다.
    
    > "이들의 정렬 및 표현 의미론은 **상위 레벨 서브시스템**에 의해 정의됩니다."

    이 데이터를 원본 타입으로 어떻게 복원할지, 즉 어떻게 "역직렬화"할지는 상위 시스템에 달려있다. 이 상위 시스템이 바로 Query processor와 같은 DBMS 윗단의 구성 요소가 되는 것이다.

- **유연한 교체**

    > "**유연성**을 위해, 키-값은 정해진 형식 없는 임의의 바이트 시퀀스가 될 수 있습니다."

    여러 스토리지 엔진이 독립적으로 개발되었으며, 각 스토리지 엔진은 고유한 특성을 가지고 있다. 우리는 이를 통해 개개인의 상황에 맞는 스토리지 엔진을 DBMS에 적용할 수 있다. 


### 우리에게 적합한 데이터베이스를 어떻게 선택할 수 있는가?

- **데이터베이스 선택이 매우 중요한 이유**

    DB는 한번 선택하면 쉽게 바꿀 수 없다. 마이그레이션은 비용이 많이 들고, 애플리케이션 코드에도 영향을 주기 때문이다. 따라서 선택한 DB가 애플리케이션에 잘 맞는지 미리 검토해야 한다.

    또한 서비스 초기에 성능 문제, 일관성 문제, 운영상의 어려움이 존재한다면, 조기에 파악하여 대처하는 것이 중요하다.

- **피상적인 비교는 금지**

    인기 순위, 구현 언어, 구성 요소 등으로만 DB를 평가하면 잘못된 결정을 내릴 수 있다. 따라서 우리 서비스 특성에 적합한 다양한 DBMS에서 테스트해보고, 이를 토대로 비교하는 것이 가장 합리적이다.

- **블랙박스 접근의 한계**

    아무리 DBMS가 추상화를 적용하여 사용자가 쓰기 편하게 한들, 내부 구조를 모르면 문제 상황에서 복구가 어렵다. 스토리지 엔진 등 내부 구조를 알고 있어야 다양한 비즈니스 리스크에 대처할 수 있다.

### 스토리지 엔진 설계에는 어떤 트레이드오프가 존재하는가?

여러 스토리지 엔진이 독립적으로 개발되었다고 했는데, 가장 완벽한 엔진이 없고 이렇게 여러 스토리지 엔진이 존재하는 이유는, 어느 부분에서 특화되었다면 그에 따른 트레이드오프가 존재하기 때문이다. 

예를 들어, 레코드를 삽입 순서대로 저장하는 구조는 쓰기 속도도는 빠르지만, 검색 시에는 정렬이 필요해 읽기 속도가 느릴 수 있다.

따라서 모든 목적에 최적화된 스토리지 엔진은 존재하지 않으며, 특정 목적에서 최적화된 스토리지 엔진만이 존재할 뿐이다. 우리는 스토리지 엔진을 선택할 때 우리의 목적에 알맞은 적절한 스토리지 엔진을 선택해야 할 것이다.

## Introduction and Overview

### DBMS의 목적에 따른 분류

DBMS는 다양한 용도의 수요에 따라 여러 형태로 존재한다.

- **저장 매체에 따른 분류**

    - Memory-based DBMS: 속도는 빠르지만 휘발성이 강하다.

    - Disk-based DBMS: 느리지만 안정적이다.

- **데이터 레이아웃에 따른 분류**

    - Row-oriented DBMS: 트랜잭션에 유리하다.

    - Column-oriented DBMS: 분석 쿼리에 유리하다.

- **기타 분류**

    - OLTP (*Online Transaction Processing*)
    
        실시간으로 많은 사용자 요청을 빠르게 처리하는 데에 유리하다. (ex. 은행 트랜잭션)

    - OLAP (*Online Analytical Processing*)

        대량의 데이터를 복잡하게 분석하는 데에 유리하다. (ex. 매출 통계 분석)

    - HTAP (*Hybrid Transactional nad Analytical Processing*)

        위 둘을 동시에 처리하는 하이브리드 시스템이다.

### DBMS의 아키텍쳐

DBMS에 표준화된 구조가 존재하진 않으나, 보통 Client-Server 모델을 따른다. 애플리케이션은 Client, DBMS는 Server의 역할을 수행한다. 물론, 분산 환경이라면 다른 DB 인스턴스가 Client가 될 수도 있다.

- **Transport layer**

    클라이언트의 요청은 쿼리 언어의 형태로 Transport layer에 전달된다. 이때 클라이언트는 애플리케이션이 될 수도, 다른 DB 클러스터 노드가 될 수도 있다.

- **Query processor**

    Transport layer는 전달받은 쿼리를 Query processor로 넘긴다. 이때, 쿼리 파서는 이 쿼리의 문법 오류 확인, 의미 해석, 권한 검사를 담당하며, 쿼리 옵티마이저는 쿼리에서 불필요한 연산을 제거하고, 내부 데이터 통계와 데이터 위치를 기반으로 가장 최적의 실행 계획을 세운다.

    - Index cardinality

        쿼리 옵티마이저의 내부 데이터 통계 기준 중 하나로, 인덱스 컬럼에 존재하는 값들의 다양한 정도를 말한다. 인덱스의 목적을 고려하면 Index cardinality가 높게 설정되어야 적절하다.

- **Execution engine**

    Query processor에서 받은 실행 계획은 Execution engine에서 로컬 실행 또는 원격 실행된다.

- **Storage engine**

    로컬 쿼리를 실행하며, 다음과 같은 컴포넌트들로 구성된다.

    - Transaction manager: DB의 ACID 성질을 보장한다.

        - Atomicity (원자성)

        - Consistency (일관성)

        - Isolation (고립성)

        - Durability (영속성)

    - Lock manager: 동시 접근 시 충돌을 방지한다.

    - Access method: 데이터를 어떤 구조로 저장할지 결정한다.

    - Buffer manager: 데이터를 메모리에 캐시한다.

    - Recover manager: 장애가 발생할 시 시스템을 복구한다.

### 메모리 기반 DBMS vs. 디스크 기반 DBMS

- **Memory-based DBMS**

    데이터를 주로 메모리에 저장하며, 디스크는 복구와 로깅용으로 사용한다. 

- **Disk-based DBMS**

    데이터를 대부분 디스크에 저장하며, 메모리는 캐시용으로 사용한다.

- **Memory-based의 이점**

    메모리에 접근하는 시간이 디스크에 접근하는 시간보다 훨씬 빨라 성능상 우위를 가지며, OS의 메모리 제어가 훨씬 간단하기 때문에 프로그래머 입장에서 제어가 편하다.

- **Disk-based의 이점**

    메모리는 비쌀 뿐더러 무엇보다 휘발성이기 때문에 데이터 손실 위험이 매우 높다. 경제성 및 안정성 면에서 디스크가 우위를 가진다.