# Weekly I Learned 8

## Transaction Processing and Recovery

DBMS에서 하나의 논리적 작업 단위를 트랜잭션이라고 일컫는다. 트랜잭션에 속하는 작업은 읽기 및 쓰기를 모두 포함하며, 한 트랜잭션에 여러 작업이 있을 수 있다.

트랜잭션은 **ACID**를 보장하며, 각각은 다음을 뜻한다.

- **A**tomicity(원자성)

    트랜잭션은 원자적이다. 즉, 나뉘어질 수 없다.

    트랜잭션은 '일시 중단'과 같은 상태가 존재할 수 없으며, 커밋되거나 실패하는 상태만 존재한다. DBMS는 실패한 트랜잭션을 Rollback하여 원자성을 보장한다.

- **C**onsistency(일관성)

    트랜잭션 이전과 이후에 DB는 유효한 상태여야 한다.

    DB에 정의된 규칙을 트랜잭션이 위반했다면 Rollback해야 한다. 애플리케이션의 비즈니스 로직에 따라 이 규칙은 변경될 수 있으며, 개발자가 신경써야 하는 유일한 속성이다.

- **I**soalation(격리성)

    트랜잭션 간 상호 간섭이 없어야 한다.

    동시에 실행되는 여러 트랜잭션은 서로 영향을 주지 않고 독립적으로 실행되는 것처럼 보여야 한다. DBMS는 Lock을 통해 병렬 실행되는 트랜잭션의 격리성을 보장한다.

- **D**urablity(지속성)

    트랜잭션 커밋 후의 결과는 DB에 영구적으로 유지되어야 한다.

    시스템 중단, 정전 등의 문제가 생기더라도, 커밋된 결과는 DB에 남아있어야 한다. DBMS는 디스크 쓰기를 보장하여 지속성을 보장한다.

### Buffer Management

- **캐싱**

    DB는 접근 속도가 느린 디스크 계층과, 접근 속도가 빠른 RAM 계층으로 분류할 수 있다. 따라서 성능 개선을 위해 **페이지 캐시**를 사용하여 디스크에서 읽은 페이지를 RAM에 캐시한다(이를 페이징이라고 한다). 때문에 시스템 장애가 발생하면 RAM에 캐시된 정보는 사라지므로, 최초의 접근 속도는 느려진다.

    그렇다면 아직 Flush하지 않은 Dirty 페이지는, DB 장애(정전 등)가 일어났을 때 RAM이 날아가 이를 반영하지 못하므로 ACID의 지속성 원칙을 위배하는 것이 아닐까?

    DB는 트랜잭션의 커밋을 완료하는 조건으로 WAL(*Write-Ahead-Logging*)가 디스크에 기록되어야 함을 두고 있다. 만약 Dirty 페이지가 날아가서 디스크에 변경사항이 반영되지 못했더라도, 디스크에 WAL 로그가 남아있으므로 DB는 재시작 시점에 WAL을 redo 하여 이를 복구한다. 즉, 지속성을 보장 가능하다.

- **캐시 만료**

    캐시된 데이터가 많다면 많은 읽기 요청을 디스크에 접근하지 않고 처리할 수 있기 때문에 성능상으로 이점을 가진다. 그러나 RAM의 크기는 한정적이므로, 모든 페이지를 캐시하는 것은 사실상 불가능하다.

    DB는 페이지 캐시에서 오래된 페이지를 제거하여 새로운 페이지를 캐시할 공간을 할당한다. 페이지가 디스크와 동기화 된 상태이거나, 고정 또는 참조된 상태가 아니라면 바로 제거해도 무방하다. 그러나 Dirty 페이지는 제거하기 전에 Flush하여 변경사항을 디스크에 반영하여야 지속성을 보장할 수 있다.

- **페이지 고정**

    가까운 시간 내에 요청될 확률이 높은 페이지는 고정시킬 수 있다. 고정된 페이지는 메모리에 더 오랜 시간 유지되므로, 디스크 접근 횟수를 줄여서 성능에 도움이 된다.

    트리 상위 레벨의 노드를 페이지 캐시에 고정해놓으면, 쿼리 요청마다 디스크에 h번 접근하지 않고 상위 레벨이 차지하는 높이만큼 그 수를 줄일 수 있으므로 성능에 도움이 된다.

    - 프리페치(Prefetch)

        페이지는 페이지 캐시에 미리(Pre) 페이징(fetch)될 수 있다. 가령 범위 스캔이 리프 노드를 순회하는 중이라면, 다음 리프 노드를 미리 페이징하여 성능을 더 개선시킨다.

    - 즉시 만료

        DB는 Maintenance Process라는 일반 쿼리와 무관한 내부 작업을 실행하기도 한다. 여기서 접근한 페이지는 일반 쿼리에서 실행할 확률이 매우 낮으므로, 즉시 캐시에서 만료시켜 캐시의 가용성을 확보한다.

- **페이지 교체 알고리즘**

    페이지 캐시가 꽉 차있는데 새로운 페이지를 추가하려면, 페이지 캐시에서 일부 페이지를 만료시켜서 제거해야 한다. 이 때, 어떤 페이지를 제거할 것인지 페이지 교체 알고리즘에 따라 제거한다.

    - FIFO(*First In First Out*)

        선입 선출. 가장 먼저 캐시에 들어온 페이지를 가장 먼저 제거한다.

        반복되는 페이지 요청 시 비효율적일 수 있으며, [Belady's Anomaly](https://en.wikipedia.org/wiki/B%C3%A9l%C3%A1dy's_anomaly) 문제가 발생할 수 있다.
        
        FIFO를 확장한 방식으로 LRU(*Least Recently Used*) 알고리즘이 있으며, 페이지가 재요청되면 큐에 그대로 두는 것이 아니라 처음 페이징 된 것 처럼 큐의 끝에 추가한다. 가장 오래 사용되지 않은 페이지가 제거되므로, Temporal Locality에서 장점이 있다.

    - CLOCK

        LRU 알고리즘의 대안으로, 원형 큐 형태로 페이지 캐시를 관리한다.

        페이지 캐시가 꽉 차서 제거할 페이지를 선택할 때, 원형 큐를 순회하며 선택한다. 접근 비트가 1인 페이지라면 0으로 바꾸고 넘어가고, 접근 비트가 0인 페이지라면 해당 페이지를 제거한다. (0이라면 해당 페이지는 최근에 접근하지 않았다는 뜻이기 때문이다.)

    그 외에 LFU(*Least Frequently Used*)와 같이, 요청 빈도가 가장 낮은 페이지를 제거하는 알고리즘도 존재한다.
