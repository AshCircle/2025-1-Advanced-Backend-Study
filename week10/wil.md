# Weekly I Learned 10

## Transaction Processing and Recovery

### Concurrency Control

- **Optimistic Concurrency Control**

    낙관적 동시성 제어(OCC, *Optimistic Concurrency Control*)는 트랜잭션 충돌이 드물다는 가정하에 작동한다. 각 트랜잭션은 커밋 전에 충돌이 발생했는지 검증하여 Serializability를 보장한다.

    OCC는 다음의 3단계로 구성된다.

    - 읽기 단계 (Read Phase)

        각 트랜잭션은 타 트랜잭션과 격리된 개별 컨텍스트에서 실행된다. 이 단계에서 읽은 데이터와 쓸 데이터가 결정된다.

    - 검증 단계 (Validation Phase)

        각 트랜잭션에 대하여, 동시에 실행된 트랜잭션들과의 충돌 여부를 검증한다. 읽은 데이터가 타 트랜잭션에 의해 수정되었다면, 실행중인 트랜잭션은 Rollback 된다.

        검증 단계는 순방향 검증, 역방향 검증으로 나눌 수 있다. 해당 트랜잭션이 검증하는 대상이 커밋 준비중인 트랜잭션이라면 **순방향 검증**이라고 하며, 해당 트랜잭션이 검증하는 대상이 이미 커밋된 트랜잭션이라면 **역방향 검증**이라고 한다.

    - 쓰기 단계 (Write Phase)

        각 트랜잭션이 검증을 통과하였으므로, 변경사항을 DB에 반영한다.

    JPA 환경에서는 @Version 어노테이션을 통하여 OCC를 구현할 수 있다. 어떤 트랜잭션에 의해 쓰기 커밋이 일어났다면 버전을 증가시키며, 다른 트랜잭션이 역방향 검증을 통해 버전이 다름을 인지한다면 해당 트랜잭션을 롤백시킨다.

- **Multiversion Concurrency Control**

    다중 버전 동시성 제어(MVCC, *Multiversion Concurrency Control*)는 하나의 레코드에 대해 여러 버전(스냅샷)을 유지하며 작동한다. 이를 통해 동시에 실행되는 트랜잭션들 간 충돌을 최소화하면서도 일관성을 유지할 수 있다.

    읽기 트랜잭션은 자신에게 일관된 스냅샷만 읽으며, 쓰기 트랜잭션은 새로운 버전을 생성한다. 새로운 버전이 커밋되기 전까지 이전 버전을 읽을 수 있기 때문에, 약간의 조정을 통해 동시 읽기 및 쓰기 작업을 수행할 수 있다.

- **Pessimistic Concurrency Control**

    비관적 동시성 제어(PCC, *Pessimistic Concurrency Control*)는 트랜잭션 충돌이 빈번하다는 가정하에 작동한다.

    구현은 다양한 방법으로 할 수 있으며, 타임스탬프 기반 제어 또는 잠금 기반 제어로 구현 가능하며, 잠금 기반 제어는 이후에 알아보고 타임스탬프 기반 제어에 대해서 조금 더 알아보자.

    타임스탬프는 max_read_timestamp와 max_write_timestamp로 나눌 수 있으며, max_read_timestamp는 해당 데이터를 가장 최근에 읽은 트랜잭션의 시각이고, max_write_timestamp는 해당 데이터를 가장 최근의 쓴 트랜잭션에 시각이다.

    - 읽기 작업 충돌 처리

        트랜잭션이 자신보다 이후의 max_write_timestamp를 부여받은 값을 읽으려고 하면 트랜잭션 순서 위반이므로 중단된다. 따라서 새로운 타임스탬프를 부여받고 트랜잭션을 다시 시작해야 한다.

    - 쓰기 작업 충돌 처리

        트랜잭션이 자신보다 이후의 max_read_timestamp를 부여받은 값에 쓰려고 하면 트랜잭션 순서 위반이므로 중단된다. 따라서 새로운 타임스탬프를 부여받고 트랜잭션을 다시 시작해야 한다.

        max_write_timestamp 이전의 트랜잭션 쓰기 작업은 무시 가능하다. 이미 신선한 값을 가진 데이터에, 이전 시점의 쓰기를 할 이유가 없기 때문이다.

- **Lock-Based Concurrency Control**

    잠금 기반 동시성 제어는 PCC의 구현 방법중 하나이다. 이 방식은 트랜잭션 간 충돌을 막기 위해 데이터 객체에 명시적으로 Lock을 걸고 다른 트랜잭션의 데이터 접근을 제어한다.

    트랜잭션이 접근하려는 데이터에 대하여 다른 트랜잭션이 이미 Lock을 획득한 상태라면, 트랜잭션은 해당 Lock이 해제되기 전까지 접근할 수 없다.
    
    여러 트랜잭션이 동일한 자원에 접근하려 해도 하나의 트랜잭션만 Lock을 획득할 수 있으므로 트랜잭션이 Lock을 획득하기 위해 계속 기다리는 상황이 발생할 수 있다. 이를 Lock Contention(락 경합)이라고 한다. Lock Contention이 발생하면 트랜잭션 지연이 증가하므로 처리량이 감소한다는 단점이 있다.

    - 2단계 잠금(2PL, *2-phase Locking*)

        2PL 기법은 가장 널리 쓰이는 Lock 기반 동시성 제어 프로토콜이다. 2PL 기법에서 트랜잭션이 락을 제어하는 방식은 다음 2단계로 나뉜다.

        1. 확장 단계

            트랜잭션은 필요한 모든 Lock을 획득하고, Lock을 해제하지 않는다.

        2. 축소 단계

            트랜잭션은 획득한 Lock들을 해제한다. 이때, Lock을 하나라도 해제했다면, 더 이상 새로운 Lock을 획득할 수 없다.

        다음 규칙을 지키면 트랜잭션의 Serializability가 보장된다.

    - Deadlock

        트랜잭션 T1이 데이터 A에 접근하여 Lock을 걸고, 트랜잭션 T2가 데이터 B에 접근하여 Lock을 걸었다. 이때, T1은 B가, T2는 A가 필요하여 서로의 Lock이 해제되길 기다린다면, 서로 무한하게 대기하는 상태가 발생할 것이다. 

        이렇게 트랜잭션들이 필요한 Lock을 획득하지 못하고 서로 기다리는 교착 상태를 **데드락**(*Deadlock*)이라고 부른다.

        Deadlock을 해결하는 여러 방법에 대해 알아보자.

        1. Timeout 기반 처리

            오랫동안 끝나지 않는 트랜잭션은 Deadlock이 발생했다고 간주하고 강제 종료한다.

            문제점: 실제로 Deadlock이 아닐 수 있는 트랜잭션까지 중단될 수 있다.

        2. Conservative 2PL

            2PL 방식을 조금 더 보수적으로 확장한 방식이다. 2PL의 확장 단계에서 필요한 모든 Lock을 한꺼번에 획득하고, 하나라도 Lock을 획득하지 못하면 트랜잭션을 중단한다.

            문제점: 시스템의 동시성이 매우 감소한다.

        3. Wait-for-graph 기반 탐지

            트랜잭션 간 대기 상태를 그래프로 표현하는 Wait-for-graph를 사용한다. 이때 그래프에서 Cycle이 발생하면 Deadlock이므로 나중에 Lock을 요청한 트랜잭션을 중단한다.

        4. Timestamp 기반 처리

            트랜잭션에 Timestamp를 부여해 충돌 시 처리 방법을 결정한다.

            - Wait-Die(대기 또는 중지)

                오래된 트랜잭션이 신규 트랜잭션의 Lock 자원을 요청하면 Wait(대기)
                
                신규 트랜잭션이 오래된 트랜잭션의 Lock 자원을 요청하면 Die(중지)

            - Wound-Wait(선점 또는 대기)

                오래된 트랜잭션이 신규 트랜잭션의 Lock 자원을 요청하면 Wound(상처입힘, 즉 신규 트랜잭션을 중지시킴)

                신규 트랜잭션이 오래된 트랜잭션의 Lock 자원을 요청하면 Wait(대기)

    - Lock vs Latch

        락(*Lock*)은 트랜잭션 간 논리적 동시성을 제어한다. 특정 키 또는 특정 범위의 키에 대해 적용되며, 동시에 수행되는 트랜잭션이 서로 영향을 주지 않도록 각 트랜잭션의 전체 기간동안 유지된다.

        래치(*Latches*)는 물리적 데이터 구조를 보호한다. B-Tree와 같은 자료구조에서 페이지 수준으로 적용되며, 리프 노드 수정 또는 상위 노드의 분할 및 병합시 사용된다.

        즉, 트랜잭션의 격리와 논리적 무결성은 Lock이, 물리적 데이터 구조 보호는 Latch가 담당한다.

    - Reader-Writer Lock

        어떤 스레드가 어떤 페이지에 Read/Write 요청을 할 때, 그에 대한 Latch를 배타적으로 획득해야 할까? Write 요청에 대해서는 반드시 그래야만 물리적인 구조를 보호할 수 있을 것이다. 그러나 Read 요청에 대해서는 배타적일 필요가 전혀 없다.

        RW Lock(*Reader-Writer Lock*)에 따르면, 여러 Reader thread는 동시에 같은 페이지에 접근 가능하며, Writer thread는 해당 페이지에 대해 그 thread만 배타적인 Latch를 획득해야만 한다.

        Pessimistic Lock-Based Control의 트랜잭션 계층에서도 RW Lock의 개념이 존재한다. Latch와 비슷하게, Read Lock이 걸린 자원에 대하여 동시에 읽기는 가능하나 쓰기는 불가능하다. 읽기를 공유한다는 의미에서 이를 공유 락(*Shared Lock*)이라고 부른다. Write Lock이 걸린 자원은 읽기와 쓰기 모두 금지되며, 해당 Lock을 획득한 트랜잭션만이 접근 가능하다. 따라서 이를 배타 락(*Exclusive Lock*)이라고 부른다.

        JPA 환경에서는 @Lock 어노테이션을 통하여 Read Lock 또는 Write Lock을 명시할 수 있다. Lock에 대하여 잘 알지는 못하나, 동일한 쿼리라도 Read Lock용 메소드와 Write Lock용 메소드를 분리하는 편이 성능 면에서 유리하다고 생각한다. Write Lock을 사용하는 쿼리 메소드를 단순 조회용 트랜잭션에서도 사용하면 배타 락이 필요하지 않은데도 배타 락을 획득하기 때문에 다른 트랜잭션에 의해 Lock Contention이 일어날 것이기 때문이다.

    - Latch Crabbing

        B-Tree 탐색 시 모든 노드에 Latch를 획득하고 내려가는 방식은 병목이 너무 심하다. Latch Crabbing은 자식 노드의 Latch를 획득하고 부모 노드의 Latch를 해제하며 병목을 줄이는 전략이다.

        부모 노드의 Latch를 해제하는 기준은 다음 두가지로 나눌 수 있다.

        - 삽입 중

            자식 노드가 꽉 차지 않았다면 구조 변경이 없으므로 부모 노드의 Latch를 해제해도 무방하다.

        - 삭제 중

            자식 노드에 충분한 데이터가 있다면 병합이 일어나지 않으므로 부모 노드의 Latch를 해제해도 무방하다.
 
    - B-link-Tree

        B-link-Tree는 B*-Tree 기반 변형 자료구조로, 동시성 제어를 개선하기 위한 목적으로 설계되었다. B*-Tree에서 노드별로 해당 노드의 최대값 키인 high key를 추가하고, 오른쪽 형제 노드를 가리키는 포인터를 추가하여 구현되었다.

        B-link-Tree의 핵심 아이디어는 다음과 같다.

        1. Half-Split 상태 허용

            기존에는 자식 노드가 가득 찬다면 자식 노드를 분할하며 새로운 노드를 생성하고, 부모 노드에 Lock을 걸고 부모 노드에 새로운 노드에 대한 포인터를 추가해야 했다. 이 방식은 부모 노드에 Lock을 걸기 때문에 병목이 발생한다는 문제가 있다. 상위 노드는 여러 트랜잭션이 동시에 접근하기 때문이다.

            B-link-Tree는 자식 노드가 가득 차면 새로운 형제 노드를 먼저 생성하고, 형제 노드로 이어지는 포인터를 통해 탐색이 가능하도록 한다. 이렇게 부모는 모르지만 형제와는 연결된 상태를 Half-Split 상태라고 한다. 부모 노드에서의 자식 포인터는 나중에 지연 업데이트를 하여 동시성 문제에서 보다 자유롭도록 한다.

        2. High Key로 상태 감지

            만일 어떤 Key를 찾아 노드로 내려왔는데, 다른 스레드에 의해 노드의 구조가 변경되었을 수 있다. B-link-Tree는 이 때 불필요한 탐색을 줄일 수 있도록, 해당 노드의 high key 값을 저장해 두어, 탐색 중인 key가 high key보다 클 경우 형제 노드로 바로 이동할 수 있도록 한다.