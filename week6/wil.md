# Weekly I Learned 6

## Implementing B-Trees

### Page Header

DBMS별로 다를 수 있으나, B-Tree 노드 하나는 보통 페이지 하나에 대응된다. 그리고 DB에서 데이터를 읽고 쓸 때 페이지 단위로 다루게 된다.

이러한 페이지의 헤더에는 페이지에 대한 여러 메타데이터들이 저장되는데, 예를 들면 페이지 레이아웃, 셀 개수, 빈 공간의 upper/lower offset 등이 저장된다. 이 페이지 헤더에 저장될 수 있는 데이터들을 좀 더 자세하게 알아보자.

- **매직 넘버**

    매직 넘버란 페이지의 종류(루트 노드, 중간 노드, 리프 노드)와 버전 정보를 포함하는 여러 바이트의 블록이다.

    또한 매직 넘버는 페이지가 정말 유효한지, 손상이 되지는 않았는지 체크하는 데에도 활용된다. 예를 들어, 어떤 페이지 위치에 접근해서 페이지 헤더를 읽었는데 매직 넘버가 일치한다면 그 페이지는 유효하다는 것을 거의 100%에 근접한 확률로 보장할 수 있다는 말이다.

- **형제 링크**

    범위 검색 시, 범위가 여러 리프 노드를 포한한다면 부모 노드를 참조해야 한다는 문제점이 있었다. 이를 해결하기 위해, 리프 노드가 형제 노드의 포인터를 가질 수 있게끔 구현한다는 방법도 살펴보았다. 이러한 형제 노드(좌우에 있는 형제 포인터 모두)를 페이지 헤더에 저장한다.

- **가장 오른쪽 포인터**

    구분 키에 대해서 알아볼 때, 구분 키가 $N$ 개 라면, $N + 1$ 개의 서브트리로 향하는 포인터가 존재했음을 기억할 것이다. 실제로 B-Tree에서는 구분 키와 포인터를 따로 저장하진 않기 때문에, $N$ 개의 구분 키와 $N$ 개의 포인터를 서로 묶어서 저장하고, 남은 1개의 가장 오른쪽 포인터(가장 오른쪽 서브트리로 향하는 포인터)를 따로 저장한다.

- **하이 키**

    가장 오른쪽 포인터를 따로 저장하는 방식과 달리, 하이 키를 사용한다는 말은 가장 오른쪽 포인터에 대응되는 키를 임의로 하나 만들어준다는 뜻이다. 이를 B-Link-Tree 라고 부른다.

    하이 키에는 가장 오른쪽 포인터가 가리키는 서브트리에서 가장 큰 키를 나타낸다. 즉, 서브트리에 저장할 수 있는 키의 상한을 나타낸다. 이 방식은 가장 오른쪽 포인터를 따로 저장하지 않고 모든 키와 포인터를 Key-Value 쌍으로 묶을 수 있으므로 일관성 있다는 장점이 있다.

- **오버플로우 페이지**

    B-Tree의 각 페이지에 할당된 고정 크기를 넘는 바이트 값이 들어온다면 어떻게 할까? 이럴 땐, 고정 크기의 바이트는 각 페이지에 저장하고, 오버플로우 페이지를 추가로 연결하여 나머지를 여기에 저장한다.

    오버플로우 페이지에도 공간이 부족한 상황이 생길 수 있다. 이러면 오버플로우 페이지에서 또 다른 오버플로우 페이지로 연결하여 저장해야 한다. 마치 Linked-List와 같이, 각 페이지 헤더에 다음 오버플로우 페이지로 연결되는 ID를 저장한다.

### Binary Search

- **간접 포인터를 사용한 이진 검색**

    B-Tree의 각 페이지에서는 데이터가 실제로 저장된 위치인 셀을 정렬하지 않고, 각 셀을 가리키는 셀 포인터만 정렬해서 이분 탐색한다. 이유는 다음과 같음을 앞에서 배웠다.

    1. 페이지 안에서 데이터를 이동시키는 비용이 크다.

    2. 삽입/삭제 연산이 빠르다.

    3. 캐시 친화적이다.

### Propagating Splits and Merges

앞에서 B-Tree의 노드 분할과 병합이 상위 레벨까지 재귀적으로 전파될 수 있음을 배웠다. 형제 포인터와 부모 포인터도 이 과정에서 알맞게 갱신해야 한다.

형제 노드를 사용한 리프 노드 순회 시, 데드락이 발생하는 것을 막기 위해 부모 노드를 사용해서 리프 노드를 순회한다. 일반적으로는 리프 노드 간 포인터, 즉 형제 노드로 따라가며 순회할 수 있지만, 여러 스레드가 서로 반대 방향으로 순회하면, 순회해야 할 곳에 서로 락이 걸려있어 데드락이 발생할 수 있다.

따라서 WiredTiger의 B-Tree 구현에서는 이러한 형제 노드 포인터 대신 부모 노드를 경유해 다음 리프 노드를 찾는 전략을 사용한다.

- **탐색 경로**

부모 포인터를 자식에 저장하는 대신, 탐색 경로를 저장해두고 이 경로를 역순으로 순회하며 분할 및 병합을 전파할 수 있다.

재귀적 구조에서 떠올릴 수 있듯이 스택 구조를 사용하며, 탐색 경로를 스택에 삽입해가며 나중에 분할 및 병합을 부모로 전파해야 한다면 이 스택을 pop 하면서 상위 노드의 주소를 참조한다.