# Weekly I Learned 5

## File Formats

### General Principles

- **헤더 & 트레일러**

    파일은 보통 고정 크기의 헤더로 시작하고, 트레일러로 끝날 수 있다. 이들은 빠르게 접근해야 하거나 파일 해석에 필요한 보조 정보를 담고 있다.

고정 길이와 가변 길이 필드가 함께 존재하는 경우, 고정 길이 필드는 앞에, 가변 길이 필드는 뒤에 배치한다.

앞에서 학습한 파스칼 문자열처럼, 가변 길이 필드의 오프셋 및 길이를 고정 길이 필드에 함께 저장하면 가변 길이 필드에 직접 접근할 수 있어 계산을 줄일 수 있다.

### Page Structure

디스크 기반 B-Tree에서 **노드(node)**는 보통 하나의 페이지에 대응된다. 리프 노드는 키와 데이터 쌍을 저장하고, 비리프 노드는 키와 자식 노드에 대한 포인터를 저장한다. 이 때문에 노드, 페이지, 블록이라는 용어가 혼용되기도 한다.

B-Tree를 처음 발표한 논문에서 제시한 고정 길이 레코드 페이지 구조는 몇몇 단점이 있는데, 다음과 같다.

- 오른쪽 이외의 위치에 키를 추가하면 요소 재배치가 필요하다.

- 고정 길이 레코드 저장에는 적합하나, 가변 길이 레코드에는 그렇지 못한다.

### Slotted Pages

가변 길이 레코드는 삭제된 레코드의 크기와 새로운 레코드 크기가 일치하지 않으면 공간 낭비가 발생하는 문제가 있다.

효율적인 페이지 포맷은 다음 조건을 충족해야 한다.

- 최소한의 오버헤드로 가변 길이 레코드 저장

- 삭제된 레코드의 메모리 회수

- 페이지의 레코드를 정확한 위치와 상관없이 참조

PostgreSQL에서 사용하는 슬롯 페이지 방식은 이를 다음과 같은 방식으로 충족시킨다.

- 오버헤드 최소화: 실제 레코드 위치를 가리키는 포인터 배열 사용이 유일한 오버헤드이다.

- 공간 회수: 단편화 제거 및 페이지 재구성을 통해 공간을 회수할 수 있다.

- 동적 레이아웃: 슬롯은 ID를 통해 외부에서 접근하므로, 정확한 위치는 페이지 내부에서만 필요하다.

### Cell Layout

페이지 내부의 모든 셀은 전부 Key 또는 Key-Value 셀이라고 가정한다.

Key 셀은 다음과 같은 구조를 따른다.

- 셀 종류

- 키 길이

- 셀이 가리키는 자식 페이지의 ID

- 키 바이트 수

Key-Value 셀은 다음과 같은 구조를 따른다. 자식 페이지 ID 대신 실제 데이터가 저장되기 때문에 값 길이 데이터와 데이터 레코드 바이트가 들어간다.

- 셀 종류

- 키 길이

- 값 길이

- 키 바이트

- 데이터 레코드 바이트

페이지 ID와 오프셋은 서로 구분되어야 하는 개념이다. 페이지 ID는 전체 파일 내의 위치를 나타내며, 실제 오프셋은 페이지 캐시가 관리한다. 오프셋은 페이지 내부에서만 유효한 개념이며, 페이지 내 시작 오프셋으로부터 상대적인 위치를 나타낸다.

### Combining Cells into Slotted Pages

셀들을 페이지에 저장할 때는 슬롯 페이지 기법을 사용한다. 셀은 오른쪽 끝에서부터 차곡차곡 저장하며, 이를 가리키는 셀 오프셋 포인터들은 왼쪽 끝에서부터 차곡차곡 저장한다.

셀은 물리적으로는 삽입 순서대로 저장되지만, 셀 오프셋 포인터들을 정렬함으로써 논리적 순서를 유지할 수 있다.

### Managing Variable-Size Data

그럼 데이터를 삭제할 때는 셀을 옮겨야 하는 상황이 일어나지 않는가 의문이 생길 수 있다. 하지만 이럴 때도 셀을 이동할 필요는 없으며, 해당 셀은 삭제됨 처리만 하면 된다.

이렇게 삭제됨 표시 된 셀은, 메모리에 저장된 가용 공간 목록에 해당 셀의 크기와 위치를 기록한다. 이후에 새 셀을 삽입할 때 이 목록을 통해 셀의 재사용 가능 여부를 파악하여 저장공간을 효율적으로 사용할 수 있다.

SQLite는 이 가용 공간 목록을 검색하는 데에 두가지 주요 전략을 사용하며, 두 전략은 서로 Trade-Off가 존재한다.

1. 최초 적합: 시간 효율적, 공간 비효율적
    
    첫 번째로 맞는 공간에 바로 삽입. 그러나 남은 공간이 쓸모없게 되는 경우가 많다.

2. 최적 적합: 공간 효율적, 시간 비효율적

    남는 공간이 가장 적은 경우를 찾아 삽입. 그러나 탐색 비용이 증가한다.

조각난 공간의 합은 새 데이터를 저장하기에 충분하지만, 연속된 공간으로 이루어지지 않아 저장할 수 없는 경우가 생길 수 있다.

이 경우 모든 셀을 읽고 재배치해서 연속된 여유 공간을 확보하면 된다. 만일 이 경우에도 공간이 부족하다면 오버플로우 페이지를 생성해야 한다.

### Versioning

DBMS는 지속적인 업데이트를 제공하므로, 버전마다 파일 구조가 달라질 수 있다. 따라서 이전 버전과의 호환성을 유지하는 것이 중요하다.

파일의 적절한 해석을 위해, 버전 정보는 다양한 방법으로 표기할 수 있다.

1. 파일명의 prefix로 버전 정보 기록

2. 개별 파일에 버전 정보 기록

3. 파일 헤더 일부에 버전 정보 기록

### Checksumming

파일은 소프트웨어 버그, 하드웨어 오류 등에 의해 손상될 수 있다. 이러한 손상을 사전에 감지하기 위해 Checksum 및 CRC(*Cyclic Redundancy Check*)를 사용한다.

- **Checksum**

    Checksum은 단순한 오류 탐지에 적합하다. 컴퓨터 네트워크 시간에 배운 Transport 계층과 Network 계층의 Checksum이 그러하듯, DB에서의 데이터 Checksum 또한 빠르지만 신뢰도가 낮다.

- **CRC**

    CRC는 연속된 비트 손상을 감지하는 데에 적합하다. Checksum이 멀티 비트 오류를 감지할 수 없는 데 반해, CRC는 멀티 비트 오류를 감지할 수 있다.
